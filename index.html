<!DOCTYPE html>
<html lang="sv">
  <head>
    <meta charset="utf-8" />
    <title>Vågande textsida – Vit bakgrund, svart text</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #fff; /* Vit bakgrund på hela sidan */
      }
      #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 999;
        font-family: sans-serif;
        background: rgba(255, 255, 255, 0.9);
        padding: 10px;
        border-radius: 4px;
      }
      label {
        display: inline-block;
        width: 80px;
      }
      #sliders > div {
        margin-bottom: 6px;
      }
    </style>
  </head>
  <body>
    <div id="ui">
      <div id="sliders">
        <div>
          <label for="amplitudeSlider">Amplitude</label>
          <input id="amplitudeSlider" type="range" min="0" max="2" step="0.01" value="0.5" />
        </div>
        <div>
          <label for="frequencySlider">Frequency</label>
          <input id="frequencySlider" type="range" min="0" max="10" step="0.1" value="2" />
        </div>
        <div>
          <label for="fovSlider">FOV</label>
          <input id="fovSlider" type="range" min="10" max="120" step="1" value="45" />
        </div>
      </div>
    </div>

    <!-- Inkludera Three.js från CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.151.3/build/three.min.js"></script>

    <script>
      // Globala variabler
      let scene, camera, renderer;
      let planeMesh; // Mesh för textsidan
      let amplitude = 0.5;
      let frequency = 2.0;
      let mouseX = 0, mouseY = 0;

      // Texten vi ska använda (Pippi-exempel)
      const pippiText = `
Hennes hår hade samma färg som en morot och var flätat i två hårda flätor som stod rätt ut.
Hennes näsa hade samma fason som en mycket liten potatis, och den var alldeles prickig av fräknar.
Under näsan satt en verkligen mycket bred mun med friska, vita tänder.
Hennes klänning var rätt egendomlig. Pippi hade själv sytt den.
Det var meningen att den skulle bli blå, men det blåa tyget räckte inte,
så Pippi fick lov att sy dit lite röda tygbitar här och där.
På hennes långa, smala ben satt ett par långa strumpor, den ena brun och den andra svart.
Och så hade hon ett par svarta skor som var precis dubbelt så långa som hennes fötter.
De skorna hade hennes pappa köpt åt henne i Sydamerika för att hon skulle ha lite att växa i,
och Pippi ville aldrig ha några andra.
      `;

      init();
      animate();

      function init() {
        // Skapa scen
        scene = new THREE.Scene();

        // Skapa kamera med initial FOV 45
        camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          2000
        );
        camera.position.set(0, 0, 600);
        camera.lookAt(scene.position);

        // Renderer med vit clearColor
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0xffffff, 1);
        document.body.appendChild(renderer.domElement);

        // Ambient ljus
        const ambientLight = new THREE.AmbientLight(0xffffff, 1);
        scene.add(ambientLight);

        // Skapa textsidans textur från en canvas med word-wrap (utan extra blankrader)
        const { texture, planeWidth, planeHeight } = createTextPageTexture(pippiText);

        // Skapa en plane geometry med segment för vågeffekt
        const segmentsX = 40;
        const segmentsY = 40;
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight, segmentsX, segmentsY);

        // Material med textur; transparent = true (så endast texten syns)
        const material = new THREE.MeshBasicMaterial({
          map: texture,
          side: THREE.DoubleSide,
          transparent: true
        });

        // Mesh – PlaneGeometry är centrerad kring (0,0,0)
        planeMesh = new THREE.Mesh(geometry, material);
        scene.add(planeMesh);
        planeMesh.position.set(0, 0, 0);

        // Event: fönsterstorlek
        window.addEventListener("resize", onWindowResize);

        // Sliders
        document.getElementById("amplitudeSlider").addEventListener("input", (e) => {
          amplitude = parseFloat(e.target.value);
        });
        document.getElementById("frequencySlider").addEventListener("input", (e) => {
          frequency = parseFloat(e.target.value);
        });
        document.getElementById("fovSlider").addEventListener("input", (e) => {
          camera.fov = parseFloat(e.target.value);
          camera.updateProjectionMatrix();
        });

        // Lägg till muslyssnare för rotation
        document.addEventListener("mousemove", onMouseMove, false);
      }

      // Skapar en textsida som texture
      function createTextPageTexture(fullText) {
        // Ange sidans bredd i pixlar (porträttformat, lik en boksida)
        const pageWidth = 400;
        const fontSize = 20;    // i pixlar
        const lineHeight = 28;  // i pixlar

        const paragraphs = fullText.trim().split("\n");

        // Temporär canvas för att mäta texten
        const measureCanvas = document.createElement("canvas");
        const measureCtx = measureCanvas.getContext("2d");
        measureCtx.font = `${fontSize}px serif`;

        let wrappedLines = [];
        paragraphs.forEach((para) => {
          if (!para.trim()) {
            // Ta inte med tomma rader
            return;
          }
          const lines = wrapText(para.trim(), pageWidth, measureCtx);
          wrappedLines = wrappedLines.concat(lines);
        });

        const totalHeight = wrappedLines.length * lineHeight;
        const textCanvas = document.createElement("canvas");
        textCanvas.width = pageWidth;
        textCanvas.height = totalHeight;

        const ctx = textCanvas.getContext("2d");
        // Låt canvasen vara transparent – endast text syns mot den vita bakgrunden på sidan
        ctx.clearRect(0, 0, textCanvas.width, textCanvas.height);

        ctx.fillStyle = "#000000";
        ctx.font = `${fontSize}px serif`;
        let y = fontSize;
        wrappedLines.forEach((line) => {
          ctx.fillText(line, 0, y);
          y += lineHeight;
        });

        const texture = new THREE.Texture(textCanvas);
        texture.needsUpdate = true;

        // Använd 1:1 pixlar som world-units (justera om så önskas)
        const planeWidth = pageWidth;
        const planeHeight = totalHeight;

        return { texture, planeWidth, planeHeight };
      }

      // Enkel word-wrap-funktion
      function wrapText(text, maxWidth, ctx) {
        const words = text.split(/\s+/);
        let lines = [];
        let currentLine = words[0];

        for (let i = 1; i < words.length; i++) {
          const testLine = currentLine + " " + words[i];
          const testWidth = ctx.measureText(testLine).width;
          if (testWidth > maxWidth) {
            lines.push(currentLine);
            currentLine = words[i];
          } else {
            currentLine = testLine;
          }
        }
        lines.push(currentLine);
        return lines;
      }

      // Uppdatera muspositionen
      function onMouseMove(event) {
        mouseX = (event.clientX / window.innerWidth) * 2 - 1;
        mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
      }

      // Animate-loop med både rotation och vågeffekt
      function animate() {
        requestAnimationFrame(animate);
        const time = performance.now() * 0.001;

        // Roterar textsidan utifrån musposition
        planeMesh.rotation.x = mouseY * 2;
        planeMesh.rotation.y = mouseX * 2;

        // Applicera vågeffekt genom att modifiera varje vertices z-koordinat
        const positions = planeMesh.geometry.attributes.position;
        for (let i = 0; i < positions.count; i++) {
          const x = positions.getX(i);
          const waveZ = Math.sin((x * 0.03 * frequency) + time) * amplitude * 20;
          positions.setZ(i, waveZ);
        }
        positions.needsUpdate = true;

        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    </script>
  </body>
</html>
